## round-57-div2/ConcatenatedArray
K=1의 경우와 Integer overflow의 경우를 잘 고려해야 한다.

## round-57-div2/DistinctPalindrome
풀이를 보고나서도 꽤나 어려웠던 문제. 탑다운식의 DP를 구성하면 이해하기 쉽고 정확한 솔루션이지만, 시간초과가 나게 된다. 따라서 바텀업식으로 만들어야 하는데, 길이가 가장 짧은놈부터 구성하면 된다. 그리고 중요한 점은 l==r인 경우에 str[l] == sigma라는 추가 조건이 들어가기 때문에, l > r의 경우는 0인녀석을 따로 처리해주지 않았는데 이 때문에 두번째 else if 케이스 구문에서 dp[0][1]에서 dp[0][0] 이런놈에 접근할 가능성이 생긴다. 따라서 솔루션 제작자는 스트링 인덱스를 1부터 셈으로써 이를 처리했는데 이걸 잘 몰라서 삽질을 많이 했다.    
Answer.cpp는 사이트에 나와있는 답안 코드이다. 인덱스를 1부터 새는 방법으로 Side Effect를 없앴다.    
BottomUpSuccess.cpp는 사이트 솔루션을 따라한 바텀업 방식 코드이다.    
BTUP_0index.cpp는 인덱스를 0부터 세지만, l==r을 체크하는 케이스에서 조건을 하나 더 추가해서 Side Effect를 없앤 코드이다. 그리고 두번째 케이스에서 값을 -하는 과정에서 MOD값에 해당 값을 뺀 값을 더하는 방식으로 처리를 했는데, 앞서 더한 값이 항상 빼는 값 보다 크기 때문에 한번에 더하고 뺀 뒤 모듈러 연산은 해도 무방하다. 물론 더하는 과정에서 overflow가 난다면 값이 달라질 수 있겠지만 두개의 수를 더해서 overflow는 나지 않기 때문에 무방하다.    
TopDownDP.cpp는 탑다운 방식인데, 중복부분 다시체크하는 로직과 함수 프롤로그 에필로그때문에 꽤나 느리다. TLE가 난다.

## round-57-div2/FastTyping
a 수열 모두 더한 값이 b수열의 가장 큰 두개값 합과 비교하면 된다.

## round-57-div2/FoxesOnAWheel
Fox와 은신처가 인접하면 1, 아니면 2의 코스트가 들게 되는데, Greedy하게 Mapping 하기 위해서 둘 중 하나를 정렬한 뒤, 왼쪽 아니면 오른쪽을 찾아서 갖다 매칭시키면 된다.