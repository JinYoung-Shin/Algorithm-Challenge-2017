## round-57-div2/ConcatenatedArray
K=1의 경우와 Integer overflow의 경우를 잘 고려해야 한다.

## round-57-div2/DistinctPalindrome
풀이를 보고나서도 꽤나 어려웠던 문제. 탑다운식의 DP를 구성하면 이해하기 쉽고 정확한 솔루션이지만, 시간초과가 나게 된다. 따라서 바텀업식으로 만들어야 하는데, 길이가 가장 짧은놈부터 구성하면 된다. 그리고 중요한 점은 l==r인 경우에 str[l] == sigma라는 추가 조건이 들어가기 때문에, l > r의 경우는 0인녀석을 따로 처리해주지 않았는데 이 때문에 두번째 else if 케이스 구문에서 dp[0][1]에서 dp[0][0] 이런놈에 접근할 가능성이 생긴다. 따라서 솔루션 제작자는 스트링 인덱스를 1부터 셈으로써 이를 처리했는데 이걸 잘 몰라서 삽질을 많이 했다.    
Answer.cpp는 사이트에 나와있는 답안 코드이다. 인덱스를 1부터 새는 방법으로 Side Effect를 없앴다.    
BottomUpSuccess.cpp는 사이트 솔루션을 따라한 바텀업 방식 코드이다.    
BTUP_0index.cpp는 인덱스를 0부터 세지만, l==r을 체크하는 케이스에서 조건을 하나 더 추가해서 Side Effect를 없앤 코드이다. 그리고 두번째 케이스에서 값을 -하는 과정에서 MOD값에 해당 값을 뺀 값을 더하는 방식으로 처리를 했는데, 앞서 더한 값이 항상 빼는 값 보다 크기 때문에 한번에 더하고 뺀 뒤 모듈러 연산은 해도 무방하다. 물론 더하는 과정에서 overflow가 난다면 값이 달라질 수 있겠지만 두개의 수를 더해서 overflow는 나지 않기 때문에 무방하다.    
TopDownDP.cpp는 탑다운 방식인데, 중복부분 다시체크하는 로직과 함수 프롤로그 에필로그때문에 꽤나 느리다. TLE가 난다.

## round-57-div2/FastTyping
a 수열 모두 더한 값이 b수열의 가장 큰 두개값 합과 비교하면 된다.

## round-57-div2/FoxesOnAWheel
Fox와 은신처가 인접하면 1, 아니면 2의 코스트가 들게 되는데, Greedy하게 Mapping 하기 위해서 둘 중 하나를 정렬한 뒤, 왼쪽 아니면 오른쪽을 찾아서 갖다 매칭시키면 된다.

## round-64/A.PrimeFactor
Interactive Contest이다. 10 이하의 자연수이므로, 경우의 수가 많지 않다. 소수도 2,3,5,7 밖에 해당되지 않으므로 해당으로 조합하면 된다.

## round-64/B.TrailingZero
Binary Search로 이루어내면 된다. Q쿼리를 통해서 TrailingZero수를 알아낸다. wrong.cpp가 실제 콘테스트에 제출한 오답이고, correct.cpp가 정답코드를 통해 재구성한 정답 코드이다. 오답 코드에서 TrailingZero -> N값을 구하는 함수만 고쳐주면 정답을 구할 수 있다. 즉 leading\_zero\_to\_N 함수가 틀려서 오답이 뜬 경우이다.
Binary Search의 경우 [)구간, 즉 Inclusive-Exclusive 구간으로 해야지 Query 개수 Limit Exceed가 일어나지 않는다. 정확한 이유는 다시 한번 분석해봐야 할 것 같다. Inclusive-Inclusive로 바이너리 서치를 할 시 Mid 값 선정에 의해서 QLE가 일어나는듯 하다. 나중에 한번 분석해 봐야 겠다.

## round-65/A.Encipherment
치환하면 된다. 배열만들어서 사부작하면 쉽다.

## round-65/B.Count4-cycles
길이 4인 Cycle이 만들어질려면, T1에서 인접한 두개의 노드가 T2에서도 인접하면 된다. 인접배열 만들어서 하면 간단하다.

## round-65/C.CrossingTree
조금 변형된 dfs를 수행한다. 일단 최단거리에 대한 조건부터 확인해야 한다. 시작점과 끝나는점이 같다면 무조건 모든 Node를 다 방문하는 길이는 edge수 * 2이다. 이 때, 최소가 되려면 시작점과 끝나는점의 거리가 최대가 되어야 한다.
이 때 시작점과 끝점의 거리를 tree의 지름이라고 부른다. 이 지름이 D라고 하면, 최단거리는 Edge수 * 2 - D가 된다. 일단 dfs를 두번하여서 트리의 지름과, 지름의 양 끝 노드를 구한다. http://koosaga.com/14 를 참고했다.
양 끝 노드를 u와 v라고 할 때, u에서 시작해서 v에서 끝나는 경로가 최단거리 경로이다. 이 경로를 구하기 위해서 조금 변형된 dfs를 수행하는데, 이미 방문한 노드를 제외한 갈 수 있는 곳의 개수를 can\_go라고 할 때, can\_go가 2개 이상일 경우
교차점이 된다. 이러할 때, 교차점 중 v로 도달할 수 있는 경로일 경우 가장 나중에 방문해야 한다. 이는 dfs2함수의 리턴값으로 알 수 있으며, v에 도달가능할 시 true를 리턴한다. 아닌 경우 false를 리턴한다.

이러한 규칙에 맞게 path를 구성하면 된다. dfs.cpp는 c++ stl vector 컨테이너를 사용한 코드이며, 이때 벡터 원소를 복사하는 횟수를 줄이기 위해서 c++ stl list 컨테이너를 사용하려고 시도하였다. 이 소스코드는 dfs_list.cpp이며
이유는 모르겠지만 원하는 값이 나오지 않았다. 아마도 list 메모리를 재사용하기 때문에 그러한 것으로 보인다.