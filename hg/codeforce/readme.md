# codeforce
코드포스의 문제를 풀이한 폴더이다.


## problemset
problemset에 있는 문제를 풀이한 폴더이다.

### 1a-theatre-square
1A번 문제 THEATRE SQUARE 문제이다. 알고리즘 자체는 간단하나, big decimal이 필요하다.

## contest-411-div2
2017년 5월 4일(목) 11시 50분부터 익일 새벽 1시 50분까지 진행된 코드포스 콘테스트이다.

### contest-411-div2/A.Fake-NP
같을때는 l을 출력, 그 외에는 2를 출력하면 답이다.

### contest-411-div2/B.3-palindrome
aabbaabb이런식으로 출력하면 답이다.

## contest-420-div2

### contest-420-div2/A.good-lab
O(n^4)로 모든 케이스를 다 해보면 정답이 나온다.    
n값이 50으로 제한이 작아서, 비벼볼만 하다

### contest-420-div2/B.banana-tree
등비수열의 합 공식을 사용해서 점을 하나 지정했을 때, 바나나 수확량을 O(1)로 구할 수 있다.    
직선따라서 x좌표 값을 바꾸어가면서 최대 y좌표 값에다가 적용하면 구할 수 있다.

### contest-420-div2/C.box-stack
하나하나 따라가다가, reorder가 필요할때 소팅하는 방식으로 하면 시간 초과가 난다.    
greedy method를 따라서 reorder를 실제로 실시하지 않고, 알아서 optimal하게 reorder했다고 가정하고 풀면 정답이다.

## contest-421-div2

### contest-421-div2/A.book-reading
하나하나 따라가면 되는 문제. 간단한 시뮬레이션 문제이다.

### contest-421-div2/B.angle
정N각형에서 나타날 수 있는 각도에 대한 패턴을 파악하면 된다.    
숫자처리 부분을 잘 못 해주어서 오답이 계속 났었다.

### contest-424-div2/A.unimodal
dfa만들어서 풀면 된다. transition만 적당히 설계하면 됨. prev값을 업데이트 해주는 것을 까먹어서 틀렸다.. 지금은 수정하여 맞춤

### contest-424-div2/B.keyboard
mapping 해주는 table을 만들어서 하나하나 1-to-1 translate 해주면 된다.

### contest-424-div2/C.jury_mark
생길 수 있는 값들을, 초기값을 임의로 두고 offset만 저장을 한다. 그리고 맵핑이 될 것들을 bias를 주어서 하나하나 모든 케이스를 고려한다.   
exhaustive search이다. 모든 케이스를 다 따진다.

### contest-426-div2/A.useless_toy
돌리는것을 모듈러 연산으로 처리하면 된다. 마이너스 값일 경우 음수가 나오는 것은 4의 배수를 더해주는 방법을 사용함.
### contest-426-div2/B.festival_evening
시작과 끝을 세서, 최대로 열린 문의 수를 센 뒤 가드 수와 비교하면 된다. 시작할때 끝도 체크를 안해줘서 계속틀렸었음.

### contest-427-div2/A.key-race
그냥 계산하면 되는문제. 문제수\*타이핑속도 + 핑\*2이 사용하는 시간이다.

### contest-427-div2/B.number
한땀한땀 새보면된다. digit 숫자개수별로 새서, 걔가 9가될때 얼만큼 add가 될 수 있는지를 계산하면 됨.

### contest-427-div2/C.stars
한땀 한땀 세보는 코드가 calc.cpp이다. 근데 이거는 timeout이 난다.    
따라서 누적합을 적용한 accum.cpp으로 풀었다. 고로 정답이다. 이거는 그래픽스에서 나왔던 개념인데, 정확하게 어디서 나왔는지는 기억이 안남..

### contest-428-div2/A
사탕을 주는 것을 하나하나 시뮬레이션 하면 된다. 첫번째 문제 답게 어렵지 않다.

### contest-428-div2/B
2번문제치고 생각보다 어렵다.    
Seat를 4명이 앉을 수 있는 경우, 2명이 앉을 수 있는 경우, 1명이 앉을 수 있는 경우로 나누어서    
그리디로 할당을 하면 되는데, 우선순위를 잘 정해줘야 한다. 딱 맞게 떨어지는 경우, best fit의 경우는 그대로 할당한다.    
그 외의 경우는 최대한 큰 seat에 할당을 하도록 해서, separate가 많이 되도록 하는 것이 유리하다.    
즉 3명을 할당해야 하는경우 1명 seat, 2명 seat가 하나이상씩 있으면 그대로 할당하는 것이 좋으나, 이 조건이 충족되지 않으면 4명짜리 seat에 앉히는 것이 1명짜리 seat 3개애 앉히는 것 보다 우선되야 한다는 것이다.   
코드포스 2~3번은 항상 그리디가 나왔던 것 같다.

### contest-428-div2/C
N이 커서 dfs로 다 안 풀릴 것 같은 우려가 될 수도 있는데, path수가 N-1개이므로, dfs로 모두 시간 안에 순회가 가능하다.    
다만 확률적으로 계속 계산을 해줘야 하는 것이, 지금 city에서 visited되지 않고 갈 수 있는 path의 수를 세서 확률을 잘 계산해줘야 한다.    
초반에 모든 경로를 다 개수를 센 뒤 평균값을 구했다가 오답이 나왔다. 착오없이 해야 한다.

## educational-27/A
첫번째 그룹의 가장 rating 낮은놈과, 두번째 그룹의 가장 rating 높은놈을 비교해주면 된다. 그룹 나눌 때는 소팅해서 높은 rating을 A팀에 몰아주면 된다.

## educational-27/B
앞쪽 뒤쪽 합을 구한뒤, 케이스를 나누어 생각한다. 예를들어 뒤쪽놈 값이 더 클 경우, 앞쪽놈의 값을 올리는 것과 뒤쪽놈의 값을 낮추는 것 중 더 효율적인 것을 찾아서 횟수를 새면 된다.

## educational-27/C
그리디로 풀 수 있다. 구간이 l, r로 나올 시 배열에 pair<int, int> (l, +1) (r+1, -1)을 넣는다. 그리고 pair.first 기준으로 정렬한다. 그리고 순서대로 second 값을 cnt에 저장해서, cnt가 3이상 값이 나오면 NO 아니면 YES이다.

## aim-tech-4-div2/A
k값 - 있는 알파뱃 수를 빼서 출력하면 된다. 길이보다 k가 클 시 impossible이다. 단, k-알파뱃수 값이 음수일때 0으로 처리를 안해주면 Hack 된다 ㅠ

## aim-tech-4-div2/B
한 열이나 행애 해당 색이 2개 이상일 경우 2^n-1 을 적용하고, 그외에 원소가 1개인 집합들은 가로,세로에서 샐 때 중복될 수 있으므로 나중에 한번씩만 더해준다. 그것이 n\*m이다.

## aim-tech-4-div2/C
pair<값, index> 로 만든 뒤 정렬을 해서, 정렬 하기 전과 정렬 한 후의 index들을 비교해본다. 집합을 만들어서 원래 인덱스 자리에 있는 놈들 집합 합쳐서 같은 집합이 되면 그놈들만 subsequence만들어서 sorting해도 정렬 이후와 동치가 된다.

## contest-432-div2/A
상수값의 범위에 따라서 답을 출력하면 된다. 간단한 문제이다.

## contest-432-div2/B
외심과 관련된 문제이다. abc 선이 한 직선위에 있지 않고, ab길이와 bc길이가 같으면 YES이다. 위 조건중 하나라도 만족되지 않으면 NO이다.

## contest-432-div2/C
모든 경우를 다 구해서 내적의 값이 음수가 아니면 실패이다. cosine 그래프를 그려보면 대충 보인다. 선형대수학과 관련이 깊은 문제이다.

## contest-434-div2/B
n값이 작기 때문에 완전탐색을 해도 된다. 층 별로 있는 flat의 수를 모두 고려해서, 만족하는 경우에 한해서 해당 층의 번호가 일정한 경우 정답, 일정하지 않는 경우 오답이다.

## contest-434-div2/D
unordered_map을 사용하면 time out이 해소된다.

# icpc-2017-2018
2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest, qualification stage (Online Mirror, ACM-ICPC Rules, Teams Preferred)이다.    
http://codeforces.com/contest/847

## icpc-2017-2018/A
링크드 리스트를 dfs방식으로 모두 찾은 뒤, 각각의 리스트들의 꼬리와 머리를 이어주면 된다.

## icpc-2017-2018/G
개수 모두 더해서 최대값을 출력하면 되는 문제. 간단하다

## icpc-2017-2018/M
등차수열인지 아닌지 확인해서 조건에 맞게 출력하면 된다. 간단하다.

## icpc-2017-2018/B
loop.cpp는 O(N^2)알고리즘이고, time limit exceed 판정이 난다. upper_bound를 이용하면 O(NlogN)으로 풀 수 있다.    
upper_bound는 해당 수 초과인 수 중에 가장 작은 수를 구하는 것이고, lower_bound는 해당 수 이상인 수 중에 가장 작은 수를 구하는 것이다. 뭔가 이름과 크게 직관적이지는 않지만 이를 이용해서 Time limit을 내지 않고 정답을 구할 수 있다.    
앞으로 가면서 여러개의 merge sequence 흐름이 있을 것인데, 점점 값이 커져야 한다. 그래서 각각 흐름의 가장 마지막 값들을 저장하고, 그 값에 대하여 upper_bound를 구하면 되는 것이다. 가장 마지막 값 보다 크지만, 그중에 최소값인 놈에 들어가는데, 관건은 주체와 객체가 바뀌어서, 해당 수 미만인 수 중에 가장 큰 수가 되어야 한다. 따라서 음수에 대하여 upper_bound를 구하면 된다.    
또한 upper_bound는 binary search 방식으로 O(logN)으로 동작하는데, 대신 바이너리 서치를 위해서 정렬된 배열이어야 한다. 정답을 알고 나면 뭔가 엄청 신기한데, 생각해내기는 어려운 알고리즘 인 듯 하다. 또한 push_back({ -x })같은 문법도 신기했다.

## manthan-codefest-17/A
STL set을 이용하면 간단하게 풀린다.

## contest-437-div1-div2/A
2글자짜리 string을 조합해서 원래 password를 조합 가능한지를 맞추는 문제이다. string 자체가 일치하는 경우와, 조합용 string의 뒷글자가 패스워드의 앞글자와 일치하는지, string의 앞글자가 패스워드의 뒷글자와 일치하는 경우가 있는지만 고려하면 된다.

## contest-437-div1-div2/B
해당 시간에 맞는 시계바늘을 그려서, t1과 t2가 시계바늘을 지나지 않고 만날 수 있는지를 확인하는 문제이다. double 같은 floating point 변수를 사용하면, 큰 수와 작은수가 섞여서 오차범위가 커질 수 있으므로, int형 변수에 분모를 생략하고 분자만 가지고 값을 사용해야 한다. calc는 double 형 변수를 사용해서 오답처리가 난 경우이고, calc_int는 정수형을 사용해서 정답이 난 경우이다.
## contest-437-div1-div2/C
문제 출재를 해서 조건에 맞는 경우를 만들 수 있는지를 확인하는 문제이다. 아는 문제의 비율이 50% 이하이여야 하는데, 잘 생각해보면 1~2문제만을 출제를 해서 조건을 맞출 수 있으면 조건을 맞출 수 있는 것이고, 아니면 맞출 수 없는 것이다. 모두가 모르는 문제가 1문제라도 있으면 무조건 YES이다. 팀이 4팀까지밖에 출전을 못하므로, 4bit로 확인해 볼 수 있으며, 모르는 문제일 경우 1bit로 set하고, 아는 문제일 경우 0bit으로 set을 한 뒤, bitwise OR연산으로 1111 형태가 나오면 출제가 가능, 아니면 불가능 하다. bit형태도 최대 16가지만 나오므로 그것만 확인하면 된다.    
only2.cpp는 2개를 고르는 모든 경우를 다 따지는데 O(N^2)로 타임아웃이 나며, bit.cpp는 O(N)으로 있는 케이스만 따지므로 정답처리가 난다.

## contest-439-dov2/A
하나하나 실제로 시뮬레이션 하면 된다. 이미 한번 나왔던 수 인지는 unordered_set으로 확인했다.
## contest-439-dov2/B
죄다 곱해버리면 될 것 같은데, 수가 커서 TLE가 나온다. 그런데 여기서 어차피 마지막 decimal digit을 구할 것이므로, 1의자리수만 고려하면 될 것 같다. 10번마다 주기적으로 회전하므로, 이를 고려하면 된다는 것! 그런데 또 보면 10번을 돈다는 것은, 0이 포함되므로 그냥 0이 나온다는 것이다. 따라서 a와 b의 차이값이 10이상이면 무조건 0이다.    
코드를 잘못 내서 hack 당했다..
```
#include <iostream>

typedef long long ll;
using namespace std;

int main() {
	ll a, b, ans;
	ans = 1;
	cin >> a >> b;
	if (b-a >= 10) ans = 0;
	b %= 10;
	a %= 10;
	for (ll k = b; k > a; k--) {
		ans *= k;
		ans %= 10;
	}
	cout << ans << endl;
}
```
잘못된 부분은 a와 b변수를 %10 해주는 부분이다. 12 9 이런 인풋을 넣으면 1로 나오게 된다. 정답은 0이다.   
brute.cpp는 정답이 나오는 코드이다.
## contest-439-div2/C
섬 a,b,c에 대하여, a-b, b-c, c-a 연결 시 다리 개수는 모두 독립적이다. a-b 연결 다리 개수는 다리가 0개일때, 1개일때, ... n개일때 모두 고려해서 더하면 된다. n개는 min(a,b) 개이며, a와 b의 섬 개수 중 최소값이다. 다리가 i개 일때는 aCi * bCi * i!의 개수가 나오게 된다. 연결에 참여할 섬들을 고른 뒤 어떻게 연결할 것인지를 곱한 값이다.

## educational-30/A
뒤쪽에서 k개의 일은 x의 시간으로 하고 나머지는 그냥 해결하면 된다.

## educational-30/B
B번 문제치고 꽤나 어려웠다. O(N^2)로 풀면 부분 최적화를 해도 시간초과가 반드시 난다. 따라서 O(N)으로 풀어야 한다. DP문제이다. dp_copy0.cpp는 TLE가 나는 오답코드이며, dp.cpp가 정답코드이다. 스트링이 0아니면 1로 구성되므로, 0개수 - 1개수 와 같은 정수(bias) 하나로 지금의 상태를 나타낼 수 있다. balanced string이려면 해당 bias값이 0이거나, 지금의 bias값과 같은 bias값이 이전에 앞에서 나타난 경우, 두 string을 빼게 되면 bias가 0이 되게 된다. 이를 이용하여 메모리 2\*N을 사용하는 dp를 구성하여 해결하면 된다.

## educational-30/C
각각의 column에서 뭉쳐있는 1들, 즉 최대 클러스터를 찾아서 다 더하면 정답이다.

# icpc-2017-2018-southern-subregional
http://codeforces.com/contest/883 의 문제들이다.

## icpc-2017-2018-southern-subregional/M
가로, 새로 길이를 구한뒤 2배하면 되고, 각각의 가로, 새로 값은 최소 2의 값을 갖는다는걸 고려해야 한다.

## icpc-2017-2018-southern-subregional/F
가장 통일된 모양으로 바꾼 뒤, 중복을 제거한 단어 개수를 새면 되는데, kh -> h / u -> oo 로 바꾸어야 한다. 왜냐면 o의 경우는 oou랑 uoo랑 같게 취급이 되어 하므로.. 뭔가 예외가 있을 것 같은데도 accept가 잘 떳으므려 정답일듯 하다.

## icpc-2017-2018-southern-subregional/E
알파뱃이 26개정도밖에 안되므로, 완전탐색을 해주면 된다. 위에 나타난 알파뱃이 해당 단어가 절대 아닌 경우에도 빼주어야 한다.

## educational-31/A
매일 읽은 양을 빼주면 된다. 간단한 문제이다.

## educational-31/B
'세그먼트 길이 + 세그먼트 수 - 1 = 길이' 이면 YES, 아니면 NO이다. 몇개의 케이스만 생각해보면 간단하다. 세그먼트 길이가 {1 , 2}라면 Unique하게 될려면 1011 밖에 없다. 길이가 4일때만 되는 셈. 길이가 5라면 01011, 10110, 10011 로 여러가이 케이스가 나온다.

## educational-31/C
조금 생각을 해야하는 문제이다. 1번 2번 조건 때문에 줄줄이 Linked list와 같은 형태를 띠게 되는데, graph 관점으로 보면 여러개의 component로 나누어진다고 볼 수 있다. 즉, 연결된 덩어리가 여러개 생길 수 있다. 그리고 각각의 component는 무조건 cycle의 형태를 띠는데 1번 2번 조건에 귀류법을 통해 증명할 수 있다. dfs로 각각의 component 크기를 다 구한 뒤, 최대 2개의 연결을 바꿀 수 있으므로, 가장 큰 두개의 component를 합친다. 그리고 각각의 컴포넌트의 원소개수를 제곱하여 더하면 정답이다.

## contest-446-div2/A
쉬운문제이다. a 수열 모두 다 더한값과, b수열 중 가장 큰 2개값 더한거랑 비교해서 b가 더 크거나 같으면 YES 아니면 NO이다.

## contest-446-div2/B
왜 자꾸 cpp로 짠 코드가 Time limit exceed가 뜨는가 싶었더니 IO 문제였다. 즉 입력값 받는데 오래 걸려서 그런것이다. 다음 코드를 추가해주니 정답이 되었다. 파이썬으로도 풀어보았다.
```
ios_base :: sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```

## educational-33/A
걍 시뮬레이션 하면 되는 문제

## educational-33/B
파이썬으로 곱해버리면 되는 문제

## educational-33/C
dfs로 찾아서 최소값들만 엮어서 더하면 된다. INF값을 너무 작게 해서(10^9보다 작은 987654321) 틀려버렷다.. 젠장 ㅠ

## contest-448-div2/A
피자가 Continuous하기 때문에 Brute Force로 해도 O(N^2)이다. N=360이므로 간단하게 가능하다.

## contest-448-div2/B
bias를 줘서 나누는 방식으로 [l, r] 범위 내에 k로 나누어떨어지는놈이 몇개인지 간단하게 알 수 있다.    
{r/k} - {(l+k-1)/k} 요놈이다. 이제 O(N^2)은 TLE가 나는데, 소팅을 하고 적용을 하면 바이너리 서치를 이용해서 O(NlgN)으로 간단하게 풀 수 있다.

## contest-449-div2/A
문제에서 원하는대로 하나하나씩 하면 쉽게 할 수 있다.

## contest-449-div2/B
1부터 숫자를 샌ㄷㅏ음에 그놈을 거꾸로해서 붙이면 ㅇ문제에서 원하는 palindrome string이 나온다.
1,2,3,4,5, -> 11 22 33 44 55 ...    
10, 11, 12, 13 ... -> 1001, 1111, 1221, 1331... 요런식이다.    
이렇게 적용하면 쉽게 풀린다.

## educational-34/A
dp로 가능한 숫자 메모해놓고 체크하면 된다.

## educational-34/B
그리디로 그때그때 상바가면서 액션을 고르면 된다.

## educational-34/C
크기가 같은 박스 개수 중 가장 개수가 많은놈 기준으로 하면 된다.

## contest-454-div2/A
가능한 모든 케이스를 다 나열해보아도 800만으로 아슬아슬하게 풀 수 있다. n값이 200이므로 200^3이다. O(N^3)

## contest-454-div2/B
알맞게 구현만 하면 되는 문제이다.

## contest-454-div2/C
과정에 따른 결과로 알파뱃 소거법으로 풀면 되는 문제이다.

## good-bye-2017/A
숫자일경우 홀수 개수, 알파뱃일 경우 vowel의 개수를 세면 된다.

## good-bye-2017/B
permutation 생성 후, 이동을 시뮬레이션 하면 된다.

## good-bye-2017/C
하나하나 원들을 비교하면서 충돌하는지 아닌지, 충돌 시 피타고라스를 이용해서 y좌표를 계산하면 된다.

## hello-2018/A
나누는 수가 2^n 형태이므로 크기가 기하급수적으로 커진다, 왼쪽수가 오른쪽수보다 작아질때까지 확인해보고 안작아진다면 실제로 mod 연산을 하고 아니라면 그 값 그대로를 리턴하면 된다.    
쉬운 문제가 가장 어렵다고, 1의 차이, 즉 <와 <=의 차이로 틀려버렸다. mod 의 우항이 좌항과 같으면 0이므로 <로 범위를 두면 안된다.

## hello-2018/B
인접리스트로 자료구조로 만든 뒤, leaf 노드들 index를 체크해놓는다. 그리고 각각 노드별로 차일드 노드가 leaf노드가 3개씩 있는지 확인해주면 된다.

## hello-2018/C
보틀 값을 정할 때 낮은 단계의 가격2배랑 비교해서 최저가로 맞추어 놓으면, 그리디로 가장 큰 리터로부터만 놓는다고 가정해도 된다. 하나 더 고려해주어야 할 경우는, 가장 큰 리터로 over-flow 시켜버릴 것인지 아니면 최소한만 챙겨줄 것인지 둘 다를 고려해야 한다.

## hello-2018/D
heap을 이용해서 푸는 시간이 가장 작은놈부터 그리디로 추가시킨 뒤, 시간이 가득 찰 경우, a값이 가장 작은놈들부터 빼낸다. 그리고 개수를 세면 된다.

## educational-36/A
약수중에 최대값을 구한 뒤, 그걸로 나눈게 답이다.
## educational-36/B
케이스를 제대로 나누지 않아서 핵당했다. 최소이동거리가 되려면, 좌우 다 닫아야하는 경우에서 다음 케이스들을 고려해야 한다.
1. pos가 [l, r] 보다 왼쪽에 있을 때
2. pos가 [l, r] 보다 오른쪽에 있을 때
3. pos가 [l, r] 사이에 있을 때. 그 중에서도 왼쪽에 가까울 때랑 오른쪽에 가까울 때가 다르다.
## educational-36/C
hacked.cpp는 오타때문에 핵당햇다. 다음 tc에서 실패한다.
```
50000000000
55555555555
```
문제가 되는 코드는 다음 코드이다.
```
if (cur_digit > 0) { //cur_digit -> 차선책
```
다음과 같이 코드를 고쳐야 한다.
```
if (lft[cur_digit] > 0) { //cur_digit -> 차선책
```

### contest-457-div2/A
분을 빼가면서 7이 포함되어 있는지를 확인하면 된다.

### contest-457-div2/C
10000보다 큰 소수중에 적당한걸 골라서, 1-n까지 인접한 수로 연결되게 길을 만든 뒤, 해당 path의 weight 합이 해당 소수와 같게 한뒤, 나머지 edge는 매우 큰 값으로 하면 된다.

### contest-459-div2/A
피보나치 수열을 만들어서 확인하면 된다.

### contest-459-div2/B
이것도 간단한 문제다. Python Dictionary같은 자료구조를 쓰면 된다.

### contest-460-div2/A
최소 a/b를 구하면 된다. 왜 C++로 풀면 계속 오답이 났는지 모르겠다.

### contest-460-div2/B
brute force로 해도 정답이 나온다고 한다. 다 더해서 10이 나오면 그다음에 가장 오른쪽 수를 0으로 만드는 수로 더하는 식으로 속도를 더 빠르게 했다.

### contest-460-div2/C
연속된 길이가 s라고 하면 s-k+1만큼 답을 더해주면 된다. 그런데 k=1일 경우 가로 세로 두번 다 세면 틀리므로, 케이스를 따로 줘야 한다.

### educational-37/A
Water tap사이의 거리의 Max로 다루면 된다. 양 끝과의 거리를 체크하고, Water tap 인덱스 값의 차를 d라고 하면, d/2+1 를 체크해야 한다.
이는 d/2의 floor값 +1이다.

### educational-37/B
큐를 실제로 만들지 않고 Linear하게 계산을 해서 체크를 할 수 있다. 커피를 먹을 경우만 시간을 +1 하면 되고, 먹는 시간은 max(온 시간, 현재 시간)으로 설정하면 된다.

### educational-37/C
연속된 1이 있을 경우 해당 범위에 대해서는 버블소팅이 되므로, 그 Range안에 있는 값들은 임의의 위치로 변경이 가능하다고 가정한다.
그리고 주어지는 수가 1~n에 유니크하게 주어지므로 인덱스만 알면 소팅되었을때 값의 범위도 알 수 있으므로 연속된 1이 있는 범위 내의 숫자들을
확인한다.

그리고 인접한 2개의 0이 있을 경우 해당 사이에 있는 숫자는 움직일수가 전혀 없으므로, 해당 숫자가 정확한 위치에 있는지를 확인하면 된다.
이 조건들을 모두 만족하면 OK이다.

그리고 양 끝 값의 경우 0이 하나만 있어도 해당 숫자가 고정되어야 하므로, 따로 처리해주면 좋다.

### contest-465-div2/A
리더수를 1명부터 n/2명까지 체크하면서, 전체 인원수 - 리더수 가 리더수로 나누어 떨어질 경우 답안에 1씩 추가하면 된다.

### contest-465-div2/B
상태를 유지하면서, gate가 아닌 곳으로 갔을 때, 이전 국가가 아닌 곳으로 나올 경우 정답 값을 1 더하고 국가 위치를 바꾸면 된다. 간단한 시뮬레이션 문제

### contest-465-div2/C
계산기하학문제이다. 일단 laptop이 flat 원 밖에 있는 경우, 원 값과 동일하게 출력하면 된다.    
laptop이 flat중심인 경우, flat에서 flat반지름 절반만큼 떨어진 아무곳에다가 flat반지름 절반으로 적용하면 된다.    
laptop이 flat원 내부이고 flat원 중심이 아닌 경우, flat원과의 거리를 d라고 할 때, d+R의 절반크기의 반지름으로 정하고, laptop위치에서 flat중심으로 가는 벡터의 길이를 AP 반지름 길이만큼 연장해서 더한 위치가 AP 위치가 된다.

### contest-465-div2/D
일단 분수 클래스를 만든다. 그리고 재귀적으로 앞에 부분부터 경우를 나누어서 확률을 계산하면 된다.(아직 버그있음)    
Q^-1 mod (10^9+7)은 Q^(10^9+5) mod (10^9+7)과 같습니다 (페르마 소정리)
나머지 연산의 곱샘 역원과 관련된 것이다.

### contest-467-div2/A
0이 아닌 점수 수를 세면 된다. set으로 쉽게 풀 수 있다.

### contest-467-div2/C
주기를 세면 된다. 처음에 oven이 켜진 시각과 키러 온 시각이 일치되는 시간까지를 1 주기라고 한다.
ceiling(오븐동작시간/키러오는시간)\*키러오는시간 이 주기 1이다. 주기 단위로 주기동안 굽는 양과 지난 시간을 계산해서
얼마나 구웠는지 확인하고 남은 양에 대해서는 앞의 오븐이 켜진 시간 동안 다 구워지는지 확인, 그게 넘는다면
오븐이 꺼진 시간에 얼마나 구워지는지를 체크하면 된다.

### contest-466-div2/A
누적합으로 일정 범위에 있는 숫자 개수를 저장해놓고, 범위가 d인 녀석으로 훑으면서, 그 범위에 들지 않은 녀석들을 모두 지워야 한다고 가정
그 지우는 녀석의 개수가 최소가 되도록 답을 구하면 된다. 범위 길이가 무조건 d라고 생각해서 시작점을 0\~d 부터 했던 것이 오답의 원인이었다.
0\~1, 0\~2, 0\~3, ... 0\~d, 1\~d+1 이런식으로 바깥 바운더리에 걸치는 범위도 확인을 해야지 정답이 됨.

### contest-466-div2/B
나누어 떨어질 경우, 나누면 얼마나 가격이 들고, 1씩 감소시키면 얼마나 가격이 드는지 그때그때 greedy하게 하면 된다.
나누어 떨어지지 않는 경우 다음 나누어 떨어지는 곳 까지 얼마나 감소시켜야 하는지, 그리고 더이상 나눌 수 없고 1까지 그냥 달려야 할경우를 나누어서 처리하면 된다.
greedy 문제.


### contest-466-div2/C
3가지 케이스로 나누어서 알고리즘을 설계할 수 있다.
n\=k일 경우, 맨 뒤쪽부터 z가 아닌 글자가 첫번째로 나오는 녀석을 찾는다. 그리고 그녀석을 기준으로
그 녀석 보다 앞애 녀석은 원본과 같게하고, 그 녀석은 원본보다 한칸 뒤의 글자로 하고, 그 녀석 보다 뒤에 녀석은
a로 도배하면 된다.

n\>k일 경우 원본의 길이 k짜리 substring을 기준으로 위 알고리즘을 시행하면 된다.

n\<k일 경우 앞에는 원본, 그리고 위네느 \(k\-n\)개만큼 a를 도배하면 된다.

### contest-466-div2/D
0에서 1로 스위치, 1에서 0으로 스위치할 때에만 l, r변수가 관련있으므로,
그때 그때 마다 가능한 l, r 변수의 최대 최소값을 구해서 업데이트 해주면 된다.

### educational-39/A
다 절대값을 취해서 더하면 정답니다.

### educational-39/B
2\*b값으로 빼는 식으로 하지 않고 해당 값으로 모듈러를 해버리면 된다.

### educational-39/C
subsequence이고 바꾸는 횟수가 minimum이 아니어도 되므로, 앞에서 시작해서 지금 필요한
녀석보다 앞의 글자면 바꾸어버리고 z까지 가는지만 확인하면 된다.

### contest-469-div2/A
dex handed를 부족한 팀에 적당히 주고, 남은 녀석을 반반찢어서 준 다음에 팀원 수를 세면 된다.

### contest-469-div2/B
누적합을 구한 뒤, 합이 같아지는 개수를 세면 된다. set자료구조를 써도 되고, 슬라이딩 윈도우 비슷하게 작은녀석을
progress 하는 방식으로 구해도 된다.

### contest-470-div2/A
.인 부분을 죄다 D를 배치하고, W가 S와 인접할 경우 No를 출력하면 됨.

### contest-464-div2/A
3번 참조해서 돌아오는지를 확인하면 된다. 간단한 문제

### contest-464-div2/B
나누어서 floor한 뒤 최대값을 구하면 된다.

### contest-464-div2/C
누적합으로 구간합을 구한 뒤 최대값 인덱스를 출력하면 되는데, 시차라는 개념 때문에 인덱스 계산이 꽤나 복잡했다.
시간이 1시간 씩 지날 때 마다 range 가 뒤쪽으로 이동한다는 것을 생각해서 누적합으로 풀면 된다.
그리고 마지막 N 경계선도 넘어갈 수 있으므로, 자료구조는 배열이더라도 실제로는 환형의 구조를 갖기 때문에
이를 고려해서 체크해야 한다.
dotorya의 코드를 참고함. accumul.cpp가 Accept를 받은 코드이다.

### april-fool-contest-2018/A
입력값에서 mod2를 출력하면 정답이다.

### april-fool-contest-2018/B
모든 부위를 다 만져본 뒤, normal이나 grumpy만 가지고 있는 응답이 나타나는 경우 해당 응답에 해당하는 결과를 리턴하면 된다.
특수문자를 제외해야하고, 띄어쓰기를 포함할 수 있다는 점을 간과하면 안된다.

### april-fool-contest-2018/C
인접한 두개의 숫자의 차의 절대값이 2 이상인 녀석이 있으면 스택이 흘러내려서 위치가 바뀐다고 했으므로
그런 경우가 있는 경우만 실패, 아니면 성공이다.

### april-fool-contest-2018/D
배팅할때 Red Odd 등에 아무거나 걸면 되는 듯하다.

### contest-464-div2/D
간단한 그리디 문제이다. 각각의 자리수의 글자를 비교해서 다른 글자일 경우 교환이 필요할 수가 있다.
하지만 이미 다른 조합으로 인해서 여러번의 치환을 통해서 같은 글자가 될 수 있는 경우가 있다.
이럴때 사용하는 것이 DSU(Disjoint Set Union)이라는 자료구조이다. 서로소 집합 자료구조라고도 하며
여러개의 원소를 서로 서로소인 집합들로 나누는 것으로 Grouping과 유사하다.
링크드 리스트를 이용하여 구현하였다.

### educational-42/A
sum을 구해서 비교하면 된다. half를 구해서 하는 방법과, 이때까지 부분합을 partial_sum이라고 할 때
partial_sum\*2 >= total_sum 으로 해도 된다. half를 구할 시 홀수일 경우 1를 더해주어야 한다.

### educational-42/B
greedy 문제이다. 연속된 좌석들 set이 있을 때 짝수일 경우 반반 띵가서 주면 되고,홀수일 경우 한놈이 1자리가 더 많다.
그러므로 인원수가 많은 쪽에 1자리가 더 많은 놈을 항상 배당하면 된다.

### educational-42/C
경우의 수가 많지 않으므로 완전 탐색을 실시하면 된다. dfs로 순회하는 방법과 bitmask를 활용하는 방법 등 다양한 방법이 존재한다.

### educational-42/D
대충보면 어려워보일 수 있지만 자료구조 문제이다. 앞에서 부터 머지한다고 했는데,
어차피 순서가 안바뀐다고 하면 4를 먼저 머지하던지 2를 먼저 머지하든지 같은 숫자중에서는
앞에 녀석을 먼저 머지하기만 하면 된다. 그리고 작은 녀석을 먼저 머지해야지 나중에 숫자가 커져서
큰 녀석을 머지할때 활용이 된다. 그래서 작은 숫자값부터 머지하며, 해당 숫자값 들 중에서는
맨 앞에서부터 머지하기만 하면 된다.
map<int, set<int> >를 활용하면 좋은데, key값은 숫자값, set에는 해당 key값에 해당되는 값의 index의 위치이다.

# helvetic-coding-test-2018

### A1.DeathStar
뒤집고 돌리다보면 8가지 경우가 나온다. 8가지 중 하나라도 일치할 시 True, 아니면 False

### B1.MaximumControl
트리에서 연결된 Edge 개수가 1개인 녀석의 개수를 세면 된다.

### C1.Encryption
누적합을 이용해서 왼쪽 오른쪽 나누어서 합을 구한뒤, 각각 합을 p로 나머지 연산해서 최대값인지 확인한다.

### D1.HyperspaceJump
분자 분모가 100이하의 정수이므로, 더해서 gcd로 나누어서 기약분수로 만든 뒤, pair<int, int>로 분수를 나타낸다.
분수별 일치하는 좌표 수를 세면 된다.

### E1.GuardDuty
계산 기하학 문제이다. 두 선분의 겹치는 조건을 CCW를 이용해서 알아낼 수 있다. 좌표가 10개씩이므로, 
완전탐색으로 풀어도 10!의 값이 1억이 안되므로, 각각의 경우 모든 좌표 조합에 대해서 Intersect하는지 확인한다.
CCW는 다음 블로그에서 참고했다.    
[CCW 참고 블로그](http://jason9319.tistory.com/358)

### F1.Lightsabers
색 별로 구간합을 구한다. 가능한 길이의 모든 구간에 대해서 확인해보면 된다.

### contest-473-div2/B
DSU관련 구현문제이다. unordered_map을 이용해서 string->index mapping하면 풀 수 있다.
구현하는데 조금 귀찮은 문제

### contest-476-div2/A
1인당 필요한 시트 수를 계산한다. ceiling(n/s)개 이며, 총 필요한 시트수는 1인당 필요한 시트 수 * 사람 수이므로
k * ceiling(n/s)이다.
ceiling(총 필요 시트 수 / p)이 정답이다.

### contest-476-div2/B
하나하나 다 해보면 된다. 똑같은 2차원 배열 만들어서 배를 놓을 수 있을 시 1씩 증가한 뒤 최대값을 갖는 좌표를 출력하면 된다.

### contest-476-div2/C
솔루션을 보고 풀었다.
[솔루션  URL](http://codeforces.com/blog/entry/59105)    
[솔루션 코드](http://codeforces.com/contest/965/submission/37617552)    

solution.cpp는 cpp로 구현했는데, long long 도 overflow가 나는 것같다. 중간 계산과정에서 나는듯하다.
파이썬으로 푼 sol.py는 accept를 받았다. main.cpp는 컨테스트 도중 시도한 것인데 망한 솔루션이다.

D값이 1000이하이므로 크지 않아서, D값을 기준으로 최대 x를 구해서 정답을 찾아보는 방식이다.
풀이 방식은 알겠는데 이렇게 간단한 코드로 푸는게 좀 신기하긴 하며 아직 100% 이해가 안된다..

### educational-40/A
인접한 두 녀석이 RU / UR 인 경우 문자열 길이에서 1씩 뺀다.

### educational-40/B
앞에서 [0 ~ i] [i+1 ~ 2*i] 문자가 같은 경우 복사해서 해버린다고 하면 된다.

### educational-40/C
값이 1씩 변화하는경우 -> 가로로 움직이는 경우
값이 x씩 (x>1) 변화하는 경우 -> 세로로 움직이는 경우

x값이 전체 가로 길이가 되며 x값이 여러개 나오는 경우 Fail이 된다.
이를 토대로 세로 길이를 구할 수 있으며, 가로 이동이 줄이 변경되는
경우 Fail이다.

### educational-53/A
NO = 스트링이 하나의 문자로만 이루어져 있는 경우    
이므로 간단하게 구현하면 된다.

### educational-53/B
숫자별 인덱스를 저장해서, 이미 Pop이 된 인덱스 인지 아닌지를 체크하면 된다.

### educational-52/A
살수있는 초코바 개수와, 이벤트로 받을 수 있는 개수를 구해서 더하면 된다. 숫자가 커보여서 파이썬을 썼다.

### educational-52/B
주어진 edge개로 커버할 수 있는 최대 버텍스 수와 최소 버텍스 수를 구해서 답을 구하면 된다.
최소 버텍스는 Perfect Graph를 구성하는 개수와 비교해서 구하면 되고, 최대 버택스는 엣지수 곱하기 2이다.
엣지당 두개의 버텍스를 이어서 커버해버리면 되므로.

### educational-52/C
delta를 활용한 같은 층의 블럭수를 구해서, 처리하면 간단하다.

### global-round-2/A
양 끝과 가장 먼 다른색들을 찾아내면 된다.

### global-round-2/B
바이너리 서치 문제이다. 오버플로에 유의할 것!

### global-round-2/C
두개 매트릭스를 xor해서 나온 1들을 모두 삭제하는 케이스를 확이하는 문제이다.
같은 열이나 행에 짝수개가 있다면 좌우로 움직여서 없앨 수 있으므로, 그 경우만 체크하면 된다.
