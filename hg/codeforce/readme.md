# codeforce
코드포스의 문제를 풀이한 폴더이다.


## problemset
problemset에 있는 문제를 풀이한 폴더이다.

### 1a-theatre-square
1A번 문제 THEATRE SQUARE 문제이다. 알고리즘 자체는 간단하나, big decimal이 필요하다.

## contest-411-div2
2017년 5월 4일(목) 11시 50분부터 익일 새벽 1시 50분까지 진행된 코드포스 콘테스트이다.

### contest-411-div2/A.Fake-NP
같을때는 l을 출력, 그 외에는 2를 출력하면 답이다.

### contest-411-div2/B.3-palindrome
aabbaabb이런식으로 출력하면 답이다.

## contest-420-div2

### contest-420-div2/A.good-lab
O(n^4)로 모든 케이스를 다 해보면 정답이 나온다.    
n값이 50으로 제한이 작아서, 비벼볼만 하다

### contest-420-div2/B.banana-tree
등비수열의 합 공식을 사용해서 점을 하나 지정했을 때, 바나나 수확량을 O(1)로 구할 수 있다.    
직선따라서 x좌표 값을 바꾸어가면서 최대 y좌표 값에다가 적용하면 구할 수 있다.

### contest-420-div2/C.box-stack
하나하나 따라가다가, reorder가 필요할때 소팅하는 방식으로 하면 시간 초과가 난다.    
greedy method를 따라서 reorder를 실제로 실시하지 않고, 알아서 optimal하게 reorder했다고 가정하고 풀면 정답이다.

## contest-421-div2

### contest-421-div2/A.book-reading
하나하나 따라가면 되는 문제. 간단한 시뮬레이션 문제이다.

### contest-421-div2/B.angle
정N각형에서 나타날 수 있는 각도에 대한 패턴을 파악하면 된다.    
숫자처리 부분을 잘 못 해주어서 오답이 계속 났었다.

### contest-424-div2/A.unimodal
dfa만들어서 풀면 된다. transition만 적당히 설계하면 됨. prev값을 업데이트 해주는 것을 까먹어서 틀렸다.. 지금은 수정하여 맞춤

### contest-424-div2/B.keyboard
mapping 해주는 table을 만들어서 하나하나 1-to-1 translate 해주면 된다.

### contest-424-div2/C.jury_mark
생길 수 있는 값들을, 초기값을 임의로 두고 offset만 저장을 한다. 그리고 맵핑이 될 것들을 bias를 주어서 하나하나 모든 케이스를 고려한다.   
exhaustive search이다. 모든 케이스를 다 따진다.

### contest-426-div2/A.useless_toy
돌리는것을 모듈러 연산으로 처리하면 된다. 마이너스 값일 경우 음수가 나오는 것은 4의 배수를 더해주는 방법을 사용함.
### contest-426-div2/B.festival_evening
시작과 끝을 세서, 최대로 열린 문의 수를 센 뒤 가드 수와 비교하면 된다. 시작할때 끝도 체크를 안해줘서 계속틀렸었음.

### contest-427-div2/A.key-race
그냥 계산하면 되는문제. 문제수\*타이핑속도 + 핑\*2이 사용하는 시간이다.

### contest-427-div2/B.number
한땀한땀 새보면된다. digit 숫자개수별로 새서, 걔가 9가될때 얼만큼 add가 될 수 있는지를 계산하면 됨.

### contest-427-div2/C.stars
한땀 한땀 세보는 코드가 calc.cpp이다. 근데 이거는 timeout이 난다.    
따라서 누적합을 적용한 accum.cpp으로 풀었다. 고로 정답이다. 이거는 그래픽스에서 나왔던 개념인데, 정확하게 어디서 나왔는지는 기억이 안남..

### contest-428-div2/A
사탕을 주는 것을 하나하나 시뮬레이션 하면 된다. 첫번째 문제 답게 어렵지 않다.

### contest-428-div2/B
2번문제치고 생각보다 어렵다.    
Seat를 4명이 앉을 수 있는 경우, 2명이 앉을 수 있는 경우, 1명이 앉을 수 있는 경우로 나누어서    
그리디로 할당을 하면 되는데, 우선순위를 잘 정해줘야 한다. 딱 맞게 떨어지는 경우, best fit의 경우는 그대로 할당한다.    
그 외의 경우는 최대한 큰 seat에 할당을 하도록 해서, separate가 많이 되도록 하는 것이 유리하다.    
즉 3명을 할당해야 하는경우 1명 seat, 2명 seat가 하나이상씩 있으면 그대로 할당하는 것이 좋으나, 이 조건이 충족되지 않으면 4명짜리 seat에 앉히는 것이 1명짜리 seat 3개애 앉히는 것 보다 우선되야 한다는 것이다.   
코드포스 2~3번은 항상 그리디가 나왔던 것 같다.

### contest-428-div2/C
N이 커서 dfs로 다 안 풀릴 것 같은 우려가 될 수도 있는데, path수가 N-1개이므로, dfs로 모두 시간 안에 순회가 가능하다.    
다만 확률적으로 계속 계산을 해줘야 하는 것이, 지금 city에서 visited되지 않고 갈 수 있는 path의 수를 세서 확률을 잘 계산해줘야 한다.    
초반에 모든 경로를 다 개수를 센 뒤 평균값을 구했다가 오답이 나왔다. 착오없이 해야 한다.

## educational-27/A
첫번째 그룹의 가장 rating 낮은놈과, 두번째 그룹의 가장 rating 높은놈을 비교해주면 된다. 그룹 나눌 때는 소팅해서 높은 rating을 A팀에 몰아주면 된다.

## educational-27/B
앞쪽 뒤쪽 합을 구한뒤, 케이스를 나누어 생각한다. 예를들어 뒤쪽놈 값이 더 클 경우, 앞쪽놈의 값을 올리는 것과 뒤쪽놈의 값을 낮추는 것 중 더 효율적인 것을 찾아서 횟수를 새면 된다.

## educational-27/C
그리디로 풀 수 있다. 구간이 l, r로 나올 시 배열에 pair<int, int> (l, +1) (r+1, -1)을 넣는다. 그리고 pair.first 기준으로 정렬한다. 그리고 순서대로 second 값을 cnt에 저장해서, cnt가 3이상 값이 나오면 NO 아니면 YES이다.

## aim-tech-4-div2/A
k값 - 있는 알파뱃 수를 빼서 출력하면 된다. 길이보다 k가 클 시 impossible이다. 단, k-알파뱃수 값이 음수일때 0으로 처리를 안해주면 Hack 된다 ㅠ

## aim-tech-4-div2/B
한 열이나 행애 해당 색이 2개 이상일 경우 2^n-1 을 적용하고, 그외에 원소가 1개인 집합들은 가로,세로에서 샐 때 중복될 수 있으므로 나중에 한번씩만 더해준다. 그것이 n\*m이다.

## aim-tech-4-div2/C
pair<값, index> 로 만든 뒤 정렬을 해서, 정렬 하기 전과 정렬 한 후의 index들을 비교해본다. 집합을 만들어서 원래 인덱스 자리에 있는 놈들 집합 합쳐서 같은 집합이 되면 그놈들만 subsequence만들어서 sorting해도 정렬 이후와 동치가 된다.

## contest-432-div2/A
상수값의 범위에 따라서 답을 출력하면 된다. 간단한 문제이다.

## contest-432-div2/B
외심과 관련된 문제이다. abc 선이 한 직선위에 있지 않고, ab길이와 bc길이가 같으면 YES이다. 위 조건중 하나라도 만족되지 않으면 NO이다.

## contest-432-div2/C
모든 경우를 다 구해서 내적의 값이 음수가 아니면 실패이다. cosine 그래프를 그려보면 대충 보인다. 선형대수학과 관련이 깊은 문제이다.

## contest-434-div2/B
n값이 작기 때문에 완전탐색을 해도 된다. 층 별로 있는 flat의 수를 모두 고려해서, 만족하는 경우에 한해서 해당 층의 번호가 일정한 경우 정답, 일정하지 않는 경우 오답이다.

## contest-434-div2/D
unordered_map을 사용하면 time out이 해소된다.

# icpc-2017-2018
2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest, qualification stage (Online Mirror, ACM-ICPC Rules, Teams Preferred)이다.    
http://codeforces.com/contest/847

## icpc-2017-2018/A
링크드 리스트를 dfs방식으로 모두 찾은 뒤, 각각의 리스트들의 꼬리와 머리를 이어주면 된다.

## icpc-2017-2018/G
개수 모두 더해서 최대값을 출력하면 되는 문제. 간단하다

## icpc-2017-2018/M
등차수열인지 아닌지 확인해서 조건에 맞게 출력하면 된다. 간단하다.

## icpc-2017-2018/B
loop.cpp는 O(N^2)알고리즘이고, time limit exceed 판정이 난다. upper_bound를 이용하면 O(NlogN)으로 풀 수 있다.    
upper_bound는 해당 수 초과인 수 중에 가장 작은 수를 구하는 것이고, lower_bound는 해당 수 이상인 수 중에 가장 작은 수를 구하는 것이다. 뭔가 이름과 크게 직관적이지는 않지만 이를 이용해서 Time limit을 내지 않고 정답을 구할 수 있다.    
앞으로 가면서 여러개의 merge sequence 흐름이 있을 것인데, 점점 값이 커져야 한다. 그래서 각각 흐름의 가장 마지막 값들을 저장하고, 그 값에 대하여 upper_bound를 구하면 되는 것이다. 가장 마지막 값 보다 크지만, 그중에 최소값인 놈에 들어가는데, 관건은 주체와 객체가 바뀌어서, 해당 수 미만인 수 중에 가장 큰 수가 되어야 한다. 따라서 음수에 대하여 upper_bound를 구하면 된다.    
또한 upper_bound는 binary search 방식으로 O(logN)으로 동작하는데, 대신 바이너리 서치를 위해서 정렬된 배열이어야 한다. 정답을 알고 나면 뭔가 엄청 신기한데, 생각해내기는 어려운 알고리즘 인 듯 하다. 또한 push_back({ -x })같은 문법도 신기했다.

## manthan-codefest-17/A
STL set을 이용하면 간단하게 풀린다.

## contest-437-div1-div2/A
2글자짜리 string을 조합해서 원래 password를 조합 가능한지를 맞추는 문제이다. string 자체가 일치하는 경우와, 조합용 string의 뒷글자가 패스워드의 앞글자와 일치하는지, string의 앞글자가 패스워드의 뒷글자와 일치하는 경우가 있는지만 고려하면 된다.

## contest-437-div1-div2/B
해당 시간에 맞는 시계바늘을 그려서, t1과 t2가 시계바늘을 지나지 않고 만날 수 있는지를 확인하는 문제이다. double 같은 floating point 변수를 사용하면, 큰 수와 작은수가 섞여서 오차범위가 커질 수 있으므로, int형 변수에 분모를 생략하고 분자만 가지고 값을 사용해야 한다. calc는 double 형 변수를 사용해서 오답처리가 난 경우이고, calc_int는 정수형을 사용해서 정답이 난 경우이다.
## contest-437-div1-div2/C
문제 출재를 해서 조건에 맞는 경우를 만들 수 있는지를 확인하는 문제이다. 아는 문제의 비율이 50% 이하이여야 하는데, 잘 생각해보면 1~2문제만을 출제를 해서 조건을 맞출 수 있으면 조건을 맞출 수 있는 것이고, 아니면 맞출 수 없는 것이다. 모두가 모르는 문제가 1문제라도 있으면 무조건 YES이다. 팀이 4팀까지밖에 출전을 못하므로, 4bit로 확인해 볼 수 있으며, 모르는 문제일 경우 1bit로 set하고, 아는 문제일 경우 0bit으로 set을 한 뒤, bitwise OR연산으로 1111 형태가 나오면 출제가 가능, 아니면 불가능 하다. bit형태도 최대 16가지만 나오므로 그것만 확인하면 된다.    
only2.cpp는 2개를 고르는 모든 경우를 다 따지는데 O(N^2)로 타임아웃이 나며, bit.cpp는 O(N)으로 있는 케이스만 따지므로 정답처리가 난다.

## contest-439-dov2/A
하나하나 실제로 시뮬레이션 하면 된다. 이미 한번 나왔던 수 인지는 unordered_set으로 확인했다.
## contest-439-dov2/B
죄다 곱해버리면 될 것 같은데, 수가 커서 TLE가 나온다. 그런데 여기서 어차피 마지막 decimal digit을 구할 것이므로, 1의자리수만 고려하면 될 것 같다. 10번마다 주기적으로 회전하므로, 이를 고려하면 된다는 것! 그런데 또 보면 10번을 돈다는 것은, 0이 포함되므로 그냥 0이 나온다는 것이다. 따라서 a와 b의 차이값이 10이상이면 무조건 0이다.    
코드를 잘못 내서 hack 당했다..
```
#include <iostream>

typedef long long ll;
using namespace std;

int main() {
	ll a, b, ans;
	ans = 1;
	cin >> a >> b;
	if (b-a >= 10) ans = 0;
	b %= 10;
	a %= 10;
	for (ll k = b; k > a; k--) {
		ans *= k;
		ans %= 10;
	}
	cout << ans << endl;
}
```
잘못된 부분은 a와 b변수를 %10 해주는 부분이다. 12 9 이런 인풋을 넣으면 1로 나오게 된다. 정답은 0이다.   
brute.cpp는 정답이 나오는 코드이다.
## contest-439-div2/C
섬 a,b,c에 대하여, a-b, b-c, c-a 연결 시 다리 개수는 모두 독립적이다. a-b 연결 다리 개수는 다리가 0개일때, 1개일때, ... n개일때 모두 고려해서 더하면 된다. n개는 min(a,b) 개이며, a와 b의 섬 개수 중 최소값이다. 다리가 i개 일때는 aCi * bCi * i!의 개수가 나오게 된다. 연결에 참여할 섬들을 고른 뒤 어떻게 연결할 것인지를 곱한 값이다.

## educational-30/A
뒤쪽에서 k개의 일은 x의 시간으로 하고 나머지는 그냥 해결하면 된다.

## educational-30/B
B번 문제치고 꽤나 어려웠다. O(N^2)로 풀면 부분 최적화를 해도 시간초과가 반드시 난다. 따라서 O(N)으로 풀어야 한다. DP문제이다. dp_copy0.cpp는 TLE가 나는 오답코드이며, dp.cpp가 정답코드이다. 스트링이 0아니면 1로 구성되므로, 0개수 - 1개수 와 같은 정수(bias) 하나로 지금의 상태를 나타낼 수 있다. balanced string이려면 해당 bias값이 0이거나, 지금의 bias값과 같은 bias값이 이전에 앞에서 나타난 경우, 두 string을 빼게 되면 bias가 0이 되게 된다. 이를 이용하여 메모리 2\*N을 사용하는 dp를 구성하여 해결하면 된다.

## educational-30/C
각각의 column에서 뭉쳐있는 1들, 즉 최대 클러스터를 찾아서 다 더하면 정답이다.

# icpc-2017-2018-southern-subregional
http://codeforces.com/contest/883 의 문제들이다.

## icpc-2017-2018-southern-subregional/M
가로, 새로 길이를 구한뒤 2배하면 되고, 각각의 가로, 새로 값은 최소 2의 값을 갖는다는걸 고려해야 한다.

## icpc-2017-2018-southern-subregional/F
가장 통일된 모양으로 바꾼 뒤, 중복을 제거한 단어 개수를 새면 되는데, kh -> h / u -> oo 로 바꾸어야 한다. 왜냐면 o의 경우는 oou랑 uoo랑 같게 취급이 되어 하므로.. 뭔가 예외가 있을 것 같은데도 accept가 잘 떳으므려 정답일듯 하다.

## icpc-2017-2018-southern-subregional/E
알파뱃이 26개정도밖에 안되므로, 완전탐색을 해주면 된다. 위에 나타난 알파뱃이 해당 단어가 절대 아닌 경우에도 빼주어야 한다.

## educational-31/A
매일 읽은 양을 빼주면 된다. 간단한 문제이다.

## educational-31/B
'세그먼트 길이 + 세그먼트 수 - 1 = 길이' 이면 YES, 아니면 NO이다. 몇개의 케이스만 생각해보면 간단하다. 세그먼트 길이가 {1 , 2}라면 Unique하게 될려면 1011 밖에 없다. 길이가 4일때만 되는 셈. 길이가 5라면 01011, 10110, 10011 로 여러가이 케이스가 나온다.

## educational-31/C
조금 생각을 해야하는 문제이다. 1번 2번 조건 때문에 줄줄이 Linked list와 같은 형태를 띠게 되는데, graph 관점으로 보면 여러개의 component로 나누어진다고 볼 수 있다. 즉, 연결된 덩어리가 여러개 생길 수 있다. 그리고 각각의 component는 무조건 cycle의 형태를 띠는데 1번 2번 조건에 귀류법을 통해 증명할 수 있다. dfs로 각각의 component 크기를 다 구한 뒤, 최대 2개의 연결을 바꿀 수 있으므로, 가장 큰 두개의 component를 합친다. 그리고 각각의 컴포넌트의 원소개수를 제곱하여 더하면 정답이다.

## contest-446-div2/A
쉬운문제이다. a 수열 모두 다 더한값과, b수열 중 가장 큰 2개값 더한거랑 비교해서 b가 더 크거나 같으면 YES 아니면 NO이다.

## contest-446-div2/B
왜 자꾸 cpp로 짠 코드가 Time limit exceed가 뜨는가 싶었더니 IO 문제였다. 즉 입력값 받는데 오래 걸려서 그런것이다. 다음 코드를 추가해주니 정답이 되었다. 파이썬으로도 풀어보았다.
```
ios_base :: sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```

## educational-33/A
걍 시뮬레이션 하면 되는 문제

## educational-33/B
파이썬으로 곱해버리면 되는 문제

## educational-33/C
dfs로 찾아서 최소값들만 엮어서 더하면 된다. INF값을 너무 작게 해서(10^9보다 작은 987654321) 틀려버렷다.. 젠장 ㅠ

## contest-448-div2/A
피자가 Continuous하기 때문에 Brute Force로 해도 O(N^2)이다. N=360이므로 간단하게 가능하다.

## contest-448-div2/B
bias를 줘서 나누는 방식으로 [l, r] 범위 내에 k로 나누어떨어지는놈이 몇개인지 간단하게 알 수 있다.    
{r/k} - {(l+k-1)/k} 요놈이다. 이제 O(N^2)은 TLE가 나는데, 소팅을 하고 적용을 하면 바이너리 서치를 이용해서 O(NlgN)으로 간단하게 풀 수 있다.

## contest-449-div2/A
문제에서 원하는대로 하나하나씩 하면 쉽게 할 수 있다.

## contest-449-div2/B
1부터 숫자를 샌ㄷㅏ음에 그놈을 거꾸로해서 붙이면 ㅇ문제에서 원하는 palindrome string이 나온다.
1,2,3,4,5, -> 11 22 33 44 55 ...    
10, 11, 12, 13 ... -> 1001, 1111, 1221, 1331... 요런식이다.    
이렇게 적용하면 쉽게 풀린다.

## educational-34/A
dp로 가능한 숫자 메모해놓고 체크하면 된다.

## educational-34/B
그리디로 그때그때 상바가면서 액션을 고르면 된다.

## educational-34/C
크기가 같은 박스 개수 중 가장 개수가 많은놈 기준으로 하면 된다.

## contest-454-div2/A
가능한 모든 케이스를 다 나열해보아도 800만으로 아슬아슬하게 풀 수 있다. n값이 200이므로 200^3이다. O(N^3)

## contest-454-div2/B
알맞게 구현만 하면 되는 문제이다.

## contest-454-div2/C
과정에 따른 결과로 알파뱃 소거법으로 풀면 되는 문제이다.

## good-bye-2017/A
숫자일경우 홀수 개수, 알파뱃일 경우 vowel의 개수를 세면 된다.

## good-bye-2017/B
permutation 생성 후, 이동을 시뮬레이션 하면 된다.

## good-bye-2017/C
하나하나 원들을 비교하면서 충돌하는지 아닌지, 충돌 시 피타고라스를 이용해서 y좌표를 계산하면 된다.

## hello-2018/A
나누는 수가 2^n 형태이므로 크기가 기하급수적으로 커진다, 왼쪽수가 오른쪽수보다 작아질때까지 확인해보고 안작아진다면 실제로 mod 연산을 하고 아니라면 그 값 그대로를 리턴하면 된다.    
쉬운 문제가 가장 어렵다고, 1의 차이, 즉 <와 <=의 차이로 틀려버렸다. mod 의 우항이 좌항과 같으면 0이므로 <로 범위를 두면 안된다.

## hello-2018/B
인접리스트로 자료구조로 만든 뒤, leaf 노드들 index를 체크해놓는다. 그리고 각각 노드별로 차일드 노드가 leaf노드가 3개씩 있는지 확인해주면 된다.

## hello-2018/C
보틀 값을 정할 때 낮은 단계의 가격2배랑 비교해서 최저가로 맞추어 놓으면, 그리디로 가장 큰 리터로부터만 놓는다고 가정해도 된다. 하나 더 고려해주어야 할 경우는, 가장 큰 리터로 over-flow 시켜버릴 것인지 아니면 최소한만 챙겨줄 것인지 둘 다를 고려해야 한다.

## hello-2018/D
heap을 이용해서 푸는 시간이 가장 작은놈부터 그리디로 추가시킨 뒤, 시간이 가득 찰 경우, a값이 가장 작은놈들부터 빼낸다. 그리고 개수를 세면 된다.

## educational-36/A
약수중에 최대값을 구한 뒤, 그걸로 나눈게 답이다.
## educational-36/B
케이스를 제대로 나누지 않아서 핵당했다. 최소이동거리가 되려면, 좌우 다 닫아야하는 경우에서 다음 케이스들을 고려해야 한다.
1. pos가 [l, r] 보다 왼쪽에 있을 때
2. pos가 [l, r] 보다 오른쪽에 있을 때
3. pos가 [l, r] 사이에 있을 때. 그 중에서도 왼쪽에 가까울 때랑 오른쪽에 가까울 때가 다르다.
## educational-36/C
hacked.cpp는 오타때문에 핵당햇다. 다음 tc에서 실패한다.
```
50000000000
55555555555
```
문제가 되는 코드는 다음 코드이다.
```
if (cur_digit > 0) { //cur_digit -> 차선책
```
다음과 같이 코드를 고쳐야 한다.
```
if (lft[cur_digit] > 0) { //cur_digit -> 차선책
```

### contest-457-div2/A
분을 빼가면서 7이 포함되어 있는지를 확인하면 된다.

### contest-457-div2/C
10000보다 큰 소수중에 적당한걸 골라서, 1-n까지 인접한 수로 연결되게 길을 만든 뒤, 해당 path의 weight 합이 해당 소수와 같게 한뒤, 나머지 edge는 매우 큰 값으로 하면 된다.

### contest-459-div2/A
피보나치 수열을 만들어서 확인하면 된다.

### contest-459-div2/B
이것도 간단한 문제다. Python Dictionary같은 자료구조를 쓰면 된다.

### contest-460-div2/A
최소 a/b를 구하면 된다. 왜 C++로 풀면 계속 오답이 났는지 모르겠다.

### contest-460-div2/B
brute force로 해도 정답이 나온다고 한다. 다 더해서 10이 나오면 그다음에 가장 오른쪽 수를 0으로 만드는 수로 더하는 식으로 속도를 더 빠르게 했다.

### contest-460-div2/C
연속된 길이가 s라고 하면 s-k+1만큼 답을 더해주면 된다. 그런데 k=1일 경우 가로 세로 두번 다 세면 틀리므로, 케이스를 따로 줘야 한다.

### educational-37/A
Water tap사이의 거리의 Max로 다루면 된다. 양 끝과의 거리를 체크하고, Water tap 인덱스 값의 차를 d라고 하면, d/2+1 를 체크해야 한다.
이는 d/2의 floor값 +1이다.

### educational-37/B
큐를 실제로 만들지 않고 Linear하게 계산을 해서 체크를 할 수 있다. 커피를 먹을 경우만 시간을 +1 하면 되고, 먹는 시간은 max(온 시간, 현재 시간)으로 설정하면 된다.

### educational-37/C
연속된 1이 있을 경우 해당 범위에 대해서는 버블소팅이 되므로, 그 Range안에 있는 값들은 임의의 위치로 변경이 가능하다고 가정한다.
그리고 주어지는 수가 1~n에 유니크하게 주어지므로 인덱스만 알면 소팅되었을때 값의 범위도 알 수 있으므로 연속된 1이 있는 범위 내의 숫자들을
확인한다.

그리고 인접한 2개의 0이 있을 경우 해당 사이에 있는 숫자는 움직일수가 전혀 없으므로, 해당 숫자가 정확한 위치에 있는지를 확인하면 된다.
이 조건들을 모두 만족하면 OK이다.

그리고 양 끝 값의 경우 0이 하나만 있어도 해당 숫자가 고정되어야 하므로, 따로 처리해주면 좋다.

### contest-465-div2/A
리더수를 1명부터 n/2명까지 체크하면서, 전체 인원수 - 리더수 가 리더수로 나누어 떨어질 경우 답안에 1씩 추가하면 된다.

### contest-465-div2/B
상태를 유지하면서, gate가 아닌 곳으로 갔을 때, 이전 국가가 아닌 곳으로 나올 경우 정답 값을 1 더하고 국가 위치를 바꾸면 된다. 간단한 시뮬레이션 문제

### contest-465-div2/C
계산기하학문제이다. 일단 laptop이 flat 원 밖에 있는 경우, 원 값과 동일하게 출력하면 된다.    
laptop이 flat중심인 경우, flat에서 flat반지름 절반만큼 떨어진 아무곳에다가 flat반지름 절반으로 적용하면 된다.    
laptop이 flat원 내부이고 flat원 중심이 아닌 경우, flat원과의 거리를 d라고 할 때, d+R의 절반크기의 반지름으로 정하고, laptop위치에서 flat중심으로 가는 벡터의 길이를 AP 반지름 길이만큼 연장해서 더한 위치가 AP 위치가 된다.

### contest-465-div2/D
일단 분수 클래스를 만든다. 그리고 재귀적으로 앞에 부분부터 경우를 나누어서 확률을 계산하면 된다.(아직 버그있음)    
Q^-1 mod (10^9+7)은 Q^(10^9+5) mod (10^9+7)과 같습니다 (페르마 소정리)
나머지 연산의 곱샘 역원과 관련된 것이다.

### contest-467-div2/A
0이 아닌 점수 수를 세면 된다. set으로 쉽게 풀 수 있다.

### contest-467-div2/C
주기를 세면 된다. 처음에 oven이 켜진 시각과 키러 온 시각이 일치되는 시간까지를 1 주기라고 한다.
ceiling(오븐동작시간/키러오는시간)\*키러오는시간 이 주기 1이다. 주기 단위로 주기동안 굽는 양과 지난 시간을 계산해서
얼마나 구웠는지 확인하고 남은 양에 대해서는 앞의 오븐이 켜진 시간 동안 다 구워지는지 확인, 그게 넘는다면
오븐이 꺼진 시간에 얼마나 구워지는지를 체크하면 된다.

### contest-466-div2/A
누적합으로 일정 범위에 있는 숫자 개수를 저장해놓고, 범위가 d인 녀석으로 훑으면서, 그 범위에 들지 않은 녀석들을 모두 지워야 한다고 가정
그 지우는 녀석의 개수가 최소가 되도록 답을 구하면 된다. 범위 길이가 무조건 d라고 생각해서 시작점을 0\~d 부터 했던 것이 오답의 원인이었다.
0\~1, 0\~2, 0\~3, ... 0\~d, 1\~d+1 이런식으로 바깥 바운더리에 걸치는 범위도 확인을 해야지 정답이 됨.

### contest-466-div2/B
나누어 떨어질 경우, 나누면 얼마나 가격이 들고, 1씩 감소시키면 얼마나 가격이 드는지 그때그때 greedy하게 하면 된다.
나누어 떨어지지 않는 경우 다음 나누어 떨어지는 곳 까지 얼마나 감소시켜야 하는지, 그리고 더이상 나눌 수 없고 1까지 그냥 달려야 할경우를 나누어서 처리하면 된다.
greedy 문제.


### contest-466-div2/C
3가지 케이스로 나누어서 알고리즘을 설계할 수 있다.
n\=k일 경우, 맨 뒤쪽부터 z가 아닌 글자가 첫번째로 나오는 녀석을 찾는다. 그리고 그녀석을 기준으로
그 녀석 보다 앞애 녀석은 원본과 같게하고, 그 녀석은 원본보다 한칸 뒤의 글자로 하고, 그 녀석 보다 뒤에 녀석은
a로 도배하면 된다.

n\>k일 경우 원본의 길이 k짜리 substring을 기준으로 위 알고리즘을 시행하면 된다.

n\<k일 경우 앞에는 원본, 그리고 위네느 \(k\-n\)개만큼 a를 도배하면 된다.

### contest-466-div2/D
0에서 1로 스위치, 1에서 0으로 스위치할 때에만 l, r변수가 관련있으므로,
그때 그때 마다 가능한 l, r 변수의 최대 최소값을 구해서 업데이트 해주면 된다.

### educational-39/A
다 절대값을 취해서 더하면 정답니다.

### educational-39/B
2\*b값으로 빼는 식으로 하지 않고 해당 값으로 모듈러를 해버리면 된다.

### educational-39/C
subsequence이고 바꾸는 횟수가 minimum이 아니어도 되므로, 앞에서 시작해서 지금 필요한
녀석보다 앞의 글자면 바꾸어버리고 z까지 가는지만 확인하면 된다.

### contest-469-div2/A
dex handed를 부족한 팀에 적당히 주고, 남은 녀석을 반반찢어서 준 다음에 팀원 수를 세면 된다.

### contest-469-div2/B
누적합을 구한 뒤, 합이 같아지는 개수를 세면 된다. set자료구조를 써도 되고, 슬라이딩 윈도우 비슷하게 작은녀석을
progress 하는 방식으로 구해도 된다.

### contest-470-div2/A
.인 부분을 죄다 D를 배치하고, W가 S와 인접할 경우 No를 출력하면 됨.