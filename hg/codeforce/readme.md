# codeforce
코드포스의 문제를 풀이한 폴더이다.


## problemset
problemset에 있는 문제를 풀이한 폴더이다.

### 1a-theatre-square
1A번 문제 THEATRE SQUARE 문제이다. 알고리즘 자체는 간단하나, big decimal이 필요하다.

## contest-411-div2
2017년 5월 4일(목) 11시 50분부터 익일 새벽 1시 50분까지 진행된 코드포스 콘테스트이다.

### contest-411-div2/A.Fake-NP
같을때는 l을 출력, 그 외에는 2를 출력하면 답이다.

### contest-411-div2/B.3-palindrome
aabbaabb이런식으로 출력하면 답이다.

## contest-420-div2

### contest-420-div2/A.good-lab
O(n^4)로 모든 케이스를 다 해보면 정답이 나온다.    
n값이 50으로 제한이 작아서, 비벼볼만 하다

### contest-420-div2/B.banana-tree
등비수열의 합 공식을 사용해서 점을 하나 지정했을 때, 바나나 수확량을 O(1)로 구할 수 있다.    
직선따라서 x좌표 값을 바꾸어가면서 최대 y좌표 값에다가 적용하면 구할 수 있다.

### contest-420-div2/C.box-stack
하나하나 따라가다가, reorder가 필요할때 소팅하는 방식으로 하면 시간 초과가 난다.    
greedy method를 따라서 reorder를 실제로 실시하지 않고, 알아서 optimal하게 reorder했다고 가정하고 풀면 정답이다.

## contest-421-div2

### contest-421-div2/A.book-reading
하나하나 따라가면 되는 문제. 간단한 시뮬레이션 문제이다.

### contest-421-div2/B.angle
정N각형에서 나타날 수 있는 각도에 대한 패턴을 파악하면 된다.    
숫자처리 부분을 잘 못 해주어서 오답이 계속 났었다.

### contest-424-div2/A.unimodal
dfa만들어서 풀면 된다. transition만 적당히 설계하면 됨. prev값을 업데이트 해주는 것을 까먹어서 틀렸다.. 지금은 수정하여 맞춤

### contest-424-div2/B.keyboard
mapping 해주는 table을 만들어서 하나하나 1-to-1 translate 해주면 된다.

### contest-424-div2/C.jury_mark
생길 수 있는 값들을, 초기값을 임의로 두고 offset만 저장을 한다. 그리고 맵핑이 될 것들을 bias를 주어서 하나하나 모든 케이스를 고려한다.   
exhaustive search이다. 모든 케이스를 다 따진다.

### contest-426-div2/A.useless_toy
돌리는것을 모듈러 연산으로 처리하면 된다. 마이너스 값일 경우 음수가 나오는 것은 4의 배수를 더해주는 방법을 사용함.
### contest-426-div2/B.festival_evening
시작과 끝을 세서, 최대로 열린 문의 수를 센 뒤 가드 수와 비교하면 된다. 시작할때 끝도 체크를 안해줘서 계속틀렸었음.

### contest-427-div2/A.key-race
그냥 계산하면 되는문제. 문제수\*타이핑속도 + 핑\*2이 사용하는 시간이다.

### contest-427-div2/B.number
한땀한땀 새보면된다. digit 숫자개수별로 새서, 걔가 9가될때 얼만큼 add가 될 수 있는지를 계산하면 됨.

### contest-427-div2/C.stars
한땀 한땀 세보는 코드가 calc.cpp이다. 근데 이거는 timeout이 난다.    
따라서 누적합을 적용한 accum.cpp으로 풀었다. 고로 정답이다. 이거는 그래픽스에서 나왔던 개념인데, 정확하게 어디서 나왔는지는 기억이 안남..

### contest-428-div2/A
사탕을 주는 것을 하나하나 시뮬레이션 하면 된다. 첫번째 문제 답게 어렵지 않다.

### contest-428-div2/B
2번문제치고 생각보다 어렵다.    
Seat를 4명이 앉을 수 있는 경우, 2명이 앉을 수 있는 경우, 1명이 앉을 수 있는 경우로 나누어서    
그리디로 할당을 하면 되는데, 우선순위를 잘 정해줘야 한다. 딱 맞게 떨어지는 경우, best fit의 경우는 그대로 할당한다.    
그 외의 경우는 최대한 큰 seat에 할당을 하도록 해서, separate가 많이 되도록 하는 것이 유리하다.    
즉 3명을 할당해야 하는경우 1명 seat, 2명 seat가 하나이상씩 있으면 그대로 할당하는 것이 좋으나, 이 조건이 충족되지 않으면 4명짜리 seat에 앉히는 것이 1명짜리 seat 3개애 앉히는 것 보다 우선되야 한다는 것이다.   
코드포스 2~3번은 항상 그리디가 나왔던 것 같다.

### contest-428-div2/C
N이 커서 dfs로 다 안 풀릴 것 같은 우려가 될 수도 있는데, path수가 N-1개이므로, dfs로 모두 시간 안에 순회가 가능하다.    
다만 확률적으로 계속 계산을 해줘야 하는 것이, 지금 city에서 visited되지 않고 갈 수 있는 path의 수를 세서 확률을 잘 계산해줘야 한다.    
초반에 모든 경로를 다 개수를 센 뒤 평균값을 구했다가 오답이 나왔다. 착오없이 해야 한다.

## educational-27/A
첫번째 그룹의 가장 rating 낮은놈과, 두번째 그룹의 가장 rating 높은놈을 비교해주면 된다. 그룹 나눌 때는 소팅해서 높은 rating을 A팀에 몰아주면 된다.

## educational-27/B
앞쪽 뒤쪽 합을 구한뒤, 케이스를 나누어 생각한다. 예를들어 뒤쪽놈 값이 더 클 경우, 앞쪽놈의 값을 올리는 것과 뒤쪽놈의 값을 낮추는 것 중 더 효율적인 것을 찾아서 횟수를 새면 된다.

## educational-27/C
그리디로 풀 수 있다. 구간이 l, r로 나올 시 배열에 pair<int, int> (l, +1) (r+1, -1)을 넣는다. 그리고 pair.first 기준으로 정렬한다. 그리고 순서대로 second 값을 cnt에 저장해서, cnt가 3이상 값이 나오면 NO 아니면 YES이다.

## aim-tech-4-div2/A
k값 - 있는 알파뱃 수를 빼서 출력하면 된다. 길이보다 k가 클 시 impossible이다. 단, k-알파뱃수 값이 음수일때 0으로 처리를 안해주면 Hack 된다 ㅠ

## aim-tech-4-div2/B
한 열이나 행애 해당 색이 2개 이상일 경우 2^n-1 을 적용하고, 그외에 원소가 1개인 집합들은 가로,세로에서 샐 때 중복될 수 있으므로 나중에 한번씩만 더해준다. 그것이 n\*m이다.

## aim-tech-4-div2/C
pair<값, index> 로 만든 뒤 정렬을 해서, 정렬 하기 전과 정렬 한 후의 index들을 비교해본다. 집합을 만들어서 원래 인덱스 자리에 있는 놈들 집합 합쳐서 같은 집합이 되면 그놈들만 subsequence만들어서 sorting해도 정렬 이후와 동치가 된다.

## contest-432-div2/A
상수값의 범위에 따라서 답을 출력하면 된다. 간단한 문제이다.

## contest-432-div2/B
외심과 관련된 문제이다. abc 선이 한 직선위에 있지 않고, ab길이와 bc길이가 같으면 YES이다. 위 조건중 하나라도 만족되지 않으면 NO이다.

## contest-432-div2/C
모든 경우를 다 구해서 내적의 값이 음수가 아니면 실패이다. cosine 그래프를 그려보면 대충 보인다. 선형대수학과 관련이 깊은 문제이다.

## contest-434-div2/B
n값이 작기 때문에 완전탐색을 해도 된다. 층 별로 있는 flat의 수를 모두 고려해서, 만족하는 경우에 한해서 해당 층의 번호가 일정한 경우 정답, 일정하지 않는 경우 오답이다.

## contest-434-div2/D
unordered_map을 사용하면 time out이 해소된다.

# icpc-2017-2018
2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest, qualification stage (Online Mirror, ACM-ICPC Rules, Teams Preferred)이다.    
http://codeforces.com/contest/847

## icpc-2017-2018/A
링크드 리스트를 dfs방식으로 모두 찾은 뒤, 각각의 리스트들의 꼬리와 머리를 이어주면 된다.

## icpc-2017-2018/G
개수 모두 더해서 최대값을 출력하면 되는 문제. 간단하다

## icpc-2017-2018/M
등차수열인지 아닌지 확인해서 조건에 맞게 출력하면 된다. 간단하다.

## icpc-2017-2018/B
loop.cpp는 O(N^2)알고리즘이고, time limit exceed 판정이 난다. upper_bound를 이용하면 O(NlogN)으로 풀 수 있다.    
upper_bound는 해당 수 초과인 수 중에 가장 작은 수를 구하는 것이고, lower_bound는 해당 수 이상인 수 중에 가장 작은 수를 구하는 것이다. 뭔가 이름과 크게 직관적이지는 않지만 이를 이용해서 Time limit을 내지 않고 정답을 구할 수 있다.    
앞으로 가면서 여러개의 merge sequence 흐름이 있을 것인데, 점점 값이 커져야 한다. 그래서 각각 흐름의 가장 마지막 값들을 저장하고, 그 값에 대하여 upper_bound를 구하면 되는 것이다. 가장 마지막 값 보다 크지만, 그중에 최소값인 놈에 들어가는데, 관건은 주체와 객체가 바뀌어서, 해당 수 미만인 수 중에 가장 큰 수가 되어야 한다. 따라서 음수에 대하여 upper_bound를 구하면 된다.    
또한 upper_bound는 binary search 방식으로 O(logN)으로 동작하는데, 대신 바이너리 서치를 위해서 정렬된 배열이어야 한다. 정답을 알고 나면 뭔가 엄청 신기한데, 생각해내기는 어려운 알고리즘 인 듯 하다. 또한 push_back({ -x })같은 문법도 신기했다.

## manthan-codefest-17/A
STL set을 이용하면 간단하게 풀린다.

## contest-437-div1-div2/A
2글자짜리 string을 조합해서 원래 password를 조합 가능한지를 맞추는 문제이다. string 자체가 일치하는 경우와, 조합용 string의 뒷글자가 패스워드의 앞글자와 일치하는지, string의 앞글자가 패스워드의 뒷글자와 일치하는 경우가 있는지만 고려하면 된다.

## contest-437-div1-div2/B
해당 시간에 맞는 시계바늘을 그려서, t1과 t2가 시계바늘을 지나지 않고 만날 수 있는지를 확인하는 문제이다. double 같은 floating point 변수를 사용하면, 큰 수와 작은수가 섞여서 오차범위가 커질 수 있으므로, int형 변수에 분모를 생략하고 분자만 가지고 값을 사용해야 한다. calc는 double 형 변수를 사용해서 오답처리가 난 경우이고, calc_int는 정수형을 사용해서 정답이 난 경우이다.
## contest-437-div1-div2/C
문제 출재를 해서 조건에 맞는 경우를 만들 수 있는지를 확인하는 문제이다. 아는 문제의 비율이 50% 이하이여야 하는데, 잘 생각해보면 1~2문제만을 출제를 해서 조건을 맞출 수 있으면 조건을 맞출 수 있는 것이고, 아니면 맞출 수 없는 것이다. 모두가 모르는 문제가 1문제라도 있으면 무조건 YES이다. 팀이 4팀까지밖에 출전을 못하므로, 4bit로 확인해 볼 수 있으며, 모르는 문제일 경우 1bit로 set하고, 아는 문제일 경우 0bit으로 set을 한 뒤, bitwise OR연산으로 1111 형태가 나오면 출제가 가능, 아니면 불가능 하다. bit형태도 최대 16가지만 나오므로 그것만 확인하면 된다.    
only2.cpp는 2개를 고르는 모든 경우를 다 따지는데 O(N^2)로 타임아웃이 나며, bit.cpp는 O(N)으로 있는 케이스만 따지므로 정답처리가 난다.

## contest-439-dov2/A
하나하나 실제로 시뮬레이션 하면 된다. 이미 한번 나왔던 수 인지는 unordered_set으로 확인했다.
## contest-439-dov2/B
죄다 곱해버리면 될 것 같은데, 수가 커서 TLE가 나온다. 그런데 여기서 어차피 마지막 decimal digit을 구할 것이므로, 1의자리수만 고려하면 될 것 같다. 10번마다 주기적으로 회전하므로, 이를 고려하면 된다는 것! 그런데 또 보면 10번을 돈다는 것은, 0이 포함되므로 그냥 0이 나온다는 것이다. 따라서 a와 b의 차이값이 10이상이면 무조건 0이다.    
코드를 잘못 내서 hack 당했다..
```
#include <iostream>

typedef long long ll;
using namespace std;

int main() {
	ll a, b, ans;
	ans = 1;
	cin >> a >> b;
	if (b-a >= 10) ans = 0;
	b %= 10;
	a %= 10;
	for (ll k = b; k > a; k--) {
		ans *= k;
		ans %= 10;
	}
	cout << ans << endl;
}
```
잘못된 부분은 a와 b변수를 %10 해주는 부분이다. 12 9 이런 인풋을 넣으면 1로 나오게 된다. 정답은 0이다.   
brute.cpp는 정답이 나오는 코드이다.
## contest-439-div2/C
섬 a,b,c에 대하여, a-b, b-c, c-a 연결 시 다리 개수는 모두 독립적이다. a-b 연결 다리 개수는 다리가 0개일때, 1개일때, ... n개일때 모두 고려해서 더하면 된다. n개는 min(a,b) 개이며, a와 b의 섬 개수 중 최소값이다. 다리가 i개 일때는 aCi * bCi * i!의 개수가 나오게 된다. 연결에 참여할 섬들을 고른 뒤 어떻게 연결할 것인지를 곱한 값이다.

## educational-30/A
뒤쪽에서 k개의 일은 x의 시간으로 하고 나머지는 그냥 해결하면 된다.

## educational-30/B
B번 문제치고 꽤나 어려웠다. O(N^2)로 풀면 부분 최적화를 해도 시간초과가 반드시 난다. 따라서 O(N)으로 풀어야 한다. DP문제이다. dp_copy0.cpp는 TLE가 나는 오답코드이며, dp.cpp가 정답코드이다. 스트링이 0아니면 1로 구성되므로, 0개수 - 1개수 와 같은 정수(bias) 하나로 지금의 상태를 나타낼 수 있다. balanced string이려면 해당 bias값이 0이거나, 지금의 bias값과 같은 bias값이 이전에 앞에서 나타난 경우, 두 string을 빼게 되면 bias가 0이 되게 된다. 이를 이용하여 메모리 2\*N을 사용하는 dp를 구성하여 해결하면 된다.

## educational-30/C
각각의 column에서 뭉쳐있는 1들, 즉 최대 클러스터를 찾아서 다 더하면 정답이다.

# icpc-2017-2018-southern-subregional
http://codeforces.com/contest/883 의 문제들이다.

## icpc-2017-2018-southern-subregional/M
가로, 새로 길이를 구한뒤 2배하면 되고, 각각의 가로, 새로 값은 최소 2의 값을 갖는다는걸 고려해야 한다.

## icpc-2017-2018-southern-subregional/F
가장 통일된 모양으로 바꾼 뒤, 중복을 제거한 단어 개수를 새면 되는데, kh -> h / u -> oo 로 바꾸어야 한다. 왜냐면 o의 경우는 oou랑 uoo랑 같게 취급이 되어 하므로.. 뭔가 예외가 있을 것 같은데도 accept가 잘 떳으므려 정답일듯 하다.

## icpc-2017-2018-southern-subregional/E
알파뱃이 26개정도밖에 안되므로, 완전탐색을 해주면 된다. 위에 나타난 알파뱃이 해당 단어가 절대 아닌 경우에도 빼주어야 한다.

## educational-31/A
매일 읽은 양을 빼주면 된다. 간단한 문제이다.

## educational-31/B
'세그먼트 길이 + 세그먼트 수 - 1 = 길이' 이면 YES, 아니면 NO이다. 몇개의 케이스만 생각해보면 간단하다. 세그먼트 길이가 {1 , 2}라면 Unique하게 될려면 1011 밖에 없다. 길이가 4일때만 되는 셈. 길이가 5라면 01011, 10110, 10011 로 여러가이 케이스가 나온다.

## educational-31/C
조금 생각을 해야하는 문제이다. 1번 2번 조건 때문에 줄줄이 Linked list와 같은 형태를 띠게 되는데, graph 관점으로 보면 여러개의 component로 나누어진다고 볼 수 있다. 즉, 연결된 덩어리가 여러개 생길 수 있다. 그리고 각각의 component는 무조건 cycle의 형태를 띠는데 1번 2번 조건에 귀류법을 통해 증명할 수 있다. dfs로 각각의 component 크기를 다 구한 뒤, 최대 2개의 연결을 바꿀 수 있으므로, 가장 큰 두개의 component를 합친다. 그리고 각각의 컴포넌트의 원소개수를 제곱하여 더하면 정답이다.